using System;
using System.Linq;
using System.Reflection;

namespace Yuumix.OdinToolkits.Modules.QoderTypeAnalyzer
{
    /// <summary>
    /// 类型数据工厂类
    /// </summary>
    public static class TypeDataFactory
    {
        #region 公共方法
        
        /// <summary>
        /// 从 Type 创建 TypeData
        /// </summary>
        /// <param name="type">类型</param>
        /// <returns>类型数据</returns>
        /// <exception cref="ArgumentNullException">type 为 null</exception>
        public static TypeData CreateTypeData(Type type)
        {
            if (type == null)
                throw new ArgumentNullException(nameof(type));
                
            var typeData = new TypeData(type);
            
            // 设置新增的属性
            typeData.TypeCategory = type.GetTypeCategory();
            typeData.AssemblyName = type.Assembly.GetName().Name;
            typeData.TypeDeclaration = type.GetTypeDeclaration();
            
            // 获取构造函数（过滤自动生成的）
            var constructors = type.GetConstructors()
                .Where(c => !MemberGenerationDetector.IsAutoGeneratedMethod(c))
                .ToArray();
            typeData.Constructors = constructors.Select(c => new MethodData(c)).ToArray();
            
            // 获取所有方法（过滤自动生成的）
            var allMethods = type.GetRuntimeMethods()
                .Where(m => !MemberGenerationDetector.IsAutoGeneratedMethod(m))
                .ToArray();
            typeData.AllMethods = allMethods.Select(m => new MethodData(m)).ToArray();
            
            // 获取所有事件（过滤自动生成的）
            var allEvents = type.GetRuntimeEvents()
                .Where(e => !MemberGenerationDetector.IsAutoGeneratedEvent(e))
                .ToArray();
            typeData.AllEvents = allEvents.Select(e => new EventData(e)).ToArray();
            
            // 获取所有字段（过滤自动生成的）
            var allFields = type.GetRuntimeFields()
                .Where(f => !MemberGenerationDetector.IsAutoGeneratedField(f))
                .ToArray();
            typeData.AllFields = allFields.Select(f => new FieldData(f)).ToArray();
            
            // 获取所有属性（过滤自动生成的）
            var allProperties = type.GetRuntimeProperties()
                .Where(p => !MemberGenerationDetector.IsAutoGeneratedProperty(p))
                .ToArray();
            typeData.AllProperties = allProperties.Select(p => new PropertyData(p)).ToArray();
            
            // 获取继承链和接口实现
            typeData.InheritanceChain = GetInheritanceChain(type);
            typeData.ImplementedInterfaces = GetImplementedInterfaces(type);
            
            return typeData;
        }
        
        /// <summary>
        /// 批量创建类型数据
        /// </summary>
        /// <param name="types">类型数组</param>
        /// <returns>类型数据数组</returns>
        /// <exception cref="ArgumentNullException">types 为 null</exception>
        public static TypeData[] CreateTypeDataArray(Type[] types)
        {
            if (types == null)
                throw new ArgumentNullException(nameof(types));
                
            var result = new TypeData[types.Length];
            
            for (int i = 0; i < types.Length; i++)
            {
                result[i] = CreateTypeData(types[i]);
            }
            
            return result;
        }
        
        /// <summary>
        /// 创建轻量级类型数据（不包含成员信息，仅用于引用）
        /// </summary>
        /// <param name="type">类型</param>
        /// <returns>轻量级类型数据</returns>
        public static TypeData CreateLightweightTypeData(Type type)
        {
            if (type == null)
                throw new ArgumentNullException(nameof(type));
                
            // 创建一个基本的 TypeData，不加载所有成员
            var typeData = new TypeData();
            typeData.TargetType = type;
            typeData.Name = type.Name;
            typeData.TypeName = type.Name;
            typeData.Namespace = type.Namespace ?? string.Empty;
            typeData.IsGeneric = type.IsGenericType;
            typeData.IsAbstract = type.IsAbstract;
            typeData.IsSealed = type.IsSealed;
            typeData.IsStatic = type.IsAbstract && type.IsSealed && !type.IsInterface;
            typeData.IsInterface = type.IsInterface;
            typeData.IsEnum = type.IsEnum;
            typeData.IsValueType = type.IsValueType;
            
            // 设置新增的属性
            typeData.TypeCategory = type.GetTypeCategory();
            typeData.AssemblyName = type.Assembly.GetName().Name;
            typeData.TypeDeclaration = type.GetTypeDeclaration();
            
            // 初始化空数组
            typeData.Constructors = new MethodData[0];
            typeData.AllMethods = new MethodData[0];
            typeData.AllEvents = new EventData[0];
            typeData.AllFields = new FieldData[0];
            typeData.AllProperties = new PropertyData[0];
            typeData.InheritanceChain = new Type[0];
            typeData.ImplementedInterfaces = new Type[0];
            typeData.GenericArguments = type.IsGenericType ? type.GetGenericArguments() : new Type[0];
            
            return typeData;
        }
        
        #endregion
        
        #region 私有方法
        
        /// <summary>
        /// 获取继承链
        /// </summary>
        /// <param name="type">类型</param>
        /// <returns>继承链类型数组</returns>
        private static Type[] GetInheritanceChain(Type type)
        {
            var chain = new System.Collections.Generic.List<Type>();
            var currentType = type.BaseType;
            
            while (currentType != null && currentType != typeof(object))
            {
                chain.Add(currentType);
                currentType = currentType.BaseType;
            }
            
            // 反转列表，使基类在前
            chain.Reverse();
            return chain.ToArray();
        }
        
        /// <summary>
        /// 获取实现的接口
        /// </summary>
        /// <param name="type">类型</param>
        /// <returns>实现的接口类型数组</returns>
        private static Type[] GetImplementedInterfaces(Type type)
        {
            return type.GetInterfaces();
        }
        
        #endregion
    }
}